## 01|基础架构:一条SQL查询语句是如何执行的

### MySQL的框架有几个组件, 各是什么作用? 

~~~markdow
客户端：提供对外服务，连接mysql服务端
连接器：管理连接，权限校验
缓存：存储、查询缓存
分析器：词法分析、语法分析
优化器：执行计划生成，选择索引
执行器：操作引擎，返回结果
存储引擎：存储数据，提供读写接口
~~~

### Server层和存储引擎层各是什么作用?

~~~markdown
server层：管理连接、校验sql、优化sql、通过server中的执行器调用存储引擎的接口，返回数据
存储引擎：存储数据、提供读写接口
~~~

### you have an error in your SQL syntax 这个保存是在词法分析里还是在语法分析里报错?

~~~markdown
会在语法分析时报错
~~~

### 对于表的操作权限验证在哪里进行?

~~~markdown
执行器
~~~

### 执行器的执行查询语句的流程是什么样的?

~~~markdown
> select * from T where ID=10;
1. 首先判断你对要执行的表有没有权限
2. 如果没有就返回没有权限的错误
3. 如果有权限就执行查询操作，如果ID没有索引，就调用innoDB引擎接口取第一行，如果ID =10，就讲结果存到结果集中，如果不是就跳过。
4. 调用存储引擎接口取下一行，重复相同的判断逻辑，直到取到这个表的最后一行
5. 执行器将满足条件的结果集返回给客户端
~~~

## 02|日志系统：一条SQL更新语句是如何执行的

### redo log的概念是什么? 为什么会存在.

~~~markdown
redo log是重做日志，主要用于mysql发生异常重启后的一种数据恢复手段。保证了数据一致性。归根到底是Mysql为了实现WAL机制的一种手段，因为Mysql进行更新操作，为了能够更快的，采用异步写回磁盘的技术。写入内存后就返回，但是会存在crash后内存数据丢失的隐患，而redo log具备crach safe能力。
~~~

### 什么是WAL(write-ahead log)机制, 好处是什么.

~~~markdown
WAL机制是写前日志，也就是Mysql更新操作后在真正的写入磁盘前先记录日志。好处是不用每一次操作都实时把数据写盘。就算crash后也可以通过redo log恢复，所以能够快速响应sql语句
~~~

### redo log 为什么可以保证crash safe机制.

~~~markdown
因为redo log 是每次更新操作完成后，就一定会写入的，如果写入失败，这说明本次操作失败，事务也不可能提交。redo log 内部是基于页的，记录了这个页的字段变化，只要crash后读取redo log进行重放就可以恢复数据。
~~~

### binlog的概念是什么, 起到什么作用, 可以做crash safe吗? 

~~~markdown
bin log 属于归档日志，属于Mysql Server层的日志。可以起到数据全量备份的作用。当需要恢复数据时，可以取出某个时间范围内的bin log进行重放恢复。但是bin log不可以做crash safe，因为crash之前，bin log可能没有写入完全Mysql就挂掉了。所以需要配合redo log才可以进行 crash safe
~~~

### binlog和redolog的不同点有哪些? 

~~~markdown
redo log 存在于innoDB引擎中、具备crash safe能力、循环写，满了就覆盖从头写，记录的是基于页的物理变化，是物理日志。
binlog 属于server层，不具备 crash safe能力，可以追加写，不会覆盖。记录的是逻辑变化，是逻辑日志。
~~~

### 物理一致性和逻辑一直性各应该怎么理解? 

~~~markdown
前者是数据一致性，后者是行为一致性。
~~~

### 执行器和innoDB在执行update语句时候的流程是什么样的?

~~~markdown
1.判断数据也是否在内存中
2.如果不存在，就从磁盘加载到内存中，如果存在就省略这一步
3.将这一行更改的数据进行运算
4.写入新行
5.新行更新到内存
6.写入redo log处于prepare阶段
7.写入binlog
8.提交事务，处于commit状态
~~~

### 如果数据库误操作, 如何执行数据恢复?

~~~markdown
数据库误删，就可以找到距离误操作最近的时间节点前的bin log，重放到临时数据库里，然后根据当天误删的数据恢复到线上数据库。
~~~

### 什么是两阶段提交, 为什么需要两阶段提交, 两阶段提交怎么保证数据库中两份日志间的逻辑一致性(什么叫逻辑一致性)?

~~~markdown
二阶段提交为；在一次update操作中，写入 redo log 进入 prepare阶段，然后写入 bin log，提交事务 redo log 处于commit阶段。保证了两分日志的逻辑一致性。
~~~

### 如果不是两阶段提交, 先写redo log和先写bin log两种情况各会遇到什么问题?

~~~markdown
先写 redo log，crash之后，bin log备份是少了一次更新操作，与当前数据不一致；
先写 bin log，crash之后，由于redo log没有写入，事务无效，当mysql重启时，数据丢失；
~~~



## 03 | 事务隔离：为什么你改了我还看不见？

### 事务的概念是什么?

~~~markdown
事务就是保证一组数据库操作，要么全部成功，要么全部失败。
~~~

### mysql的事务隔离级别读未提交, 读已提交, 可重复读, 串行各是什么意思?

~~~markdown
读未提交：一个事务还没有提交，它做的变更就可以被别的事务看到。
读已提交：一个事务提交之后，它做的变更就可以被其他事务看到。
可重复读：一个事务执行的过程中看到的数据，总是根这个时候刚启动时看到的数据是一致的。
串行化：对于同一行记录，”写“和”读“都会加”锁“，当出现读写冲突是，后访问的事务必须等待前一个事务执行完成，才能执行。
~~~

### 读已提交, 可重复读是怎么通过视图构建实现的?

~~~markdown
读已提交：会在事务中的每一个sql语句执行的时候都为对应的SQL创建一个一致性视图。此时这个SQL能读取到已提交的事务对数据的操作。
可重复读：会在事务开启的时候，为整个事务创建一个一致性试图，这个试图会贯穿到这个事务执行结束。在整个事务执行过程中，都使用这个视图中的数据作为一致性读的依据。
~~~

### 可重复读的使用场景举例? 对账的时候应该很有用?

~~~markdown
对账的时候
库管盘货
~~~

### 事务隔离是怎么通过read-view(读视图)实现的?

~~~markdown
每一行数据会有多个版本，当我们要去读取数据的时候，要判断这个数据的版本号，对当前事务而言，是否可见，如果不可见，则要根据undo log 计算得到上一个版本，如果上一个版本也不符合要求，则要找到再上一个版本，直到找到对应正确的数据版本。
~~~

### 并发版本控制(MVCC)的概念是什么, 是怎么实现的?

~~~markdown
同一个数据行，在数据库中存在多个版本号，这个版本号可以理解为当初操作这行数据的事务的事务ID。当多个事务在并发进行的时候，判断某个事务是否可以读取到某一行时，
会使用行的版本号，和当前事务的ID进行比较。如果发现比这个事务ID小，表示之前的事务提交的操作，对当前事务来说，此版本的数据可见。
如果发现这个数据的版本号比当前事务的ID大，则表示有未来发生的事务提交生成的，对当前事务来说，此版本的数据不可见。
如果发现这个竖行的版本号刚好等于某个正在运行的是事务ID，表示当前数据是由正运行的某个事务提交生成的，对当前事务来说，此版本数据不可见。
如果当前事务自己修改的数据，当前事务还是可以看到的。
~~~

### 使用长事务的弊病? 为什么使用常事务可能拖垮整个库?

~~~markdown
长事务导致表空间持续增长，即便是事务提交或者回滚后，回滚表空间被是否后，表空间大小仍然不会被缩小。
长事务的存在导致锁发生冲突或等待的几率大大增加。
如果某个应用有发生锁等待后尝试重新建立连接的机制，那么在发生锁等待或冲突的时候，应用就会不断地发起新的连接，导致MySQL的连接数被占用爆满。MySQL不能在提供连接服务，就挂掉了。
~~~

### 事务的启动方式有哪几种? 

~~~markdown
begin；-一致性读的视图不会马上创建，而是在执行begin后面的第一个操作innodb表的SQL语句时生成。这个SQL可以是select，update，delete，insert。事务ID也是此时被分配的
start transaction；一和begin的功能效果一样。
start transaciton with consistent snapshot；一该语句执行后，会马上创建一致性读的视图。 这个是它和begin的区别。事务ID也是此时被分配的。
~~~

### commit work and chain的语法是做什么用的? 

~~~markdown
提交上一个事务，并且再开启一个新的事务。它的功能等效于：commit+ begin。
~~~

### 怎么查询各个表中的长事务?

~~~markdown
select* from information_schema. innodb_trx;
这个表中记录了所有正在运行的事务信息,里面有事务的开始时间。可以从这里看出哪些事务运行的时间比较长。
~~~

### 如何避免长事务的出现?

~~~markdown
从数据库方面：
a.设置autocommit=1，不要设置为0。
b.写脚本监控information_schemal.innodb_trx表中数据内容，发现长事务，kil掉它。
c.配置SQL语句所能执行的最大运行时间，如果查过最大运行时间后，中断这个运行事情长的SQL语句。
d.设置回滚表空单独存放，便于回收表空间。
从业务代码方面：
a.确认是否使用了autocommit=0的配置，如果有关闭它，然后再业务代码中手动的使用begin；commit来操作。
b.检查业务逻辑代码，能拆分为小事务的不要用大事务。
c.检查代码，把没有必要的select语句被事务包裹的情况去掉。
~~~



## 04 | 深入浅出索引（上）

### 总结

~~~markdown
1.索引的作用：提高数据查询效率
2.常见索引模型：哈希表、有序数组、搜索树
3.哈希表：键-值（key- value）。
4.哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置
5.哈希冲突的处理办法：链表
6.哈希表适用场景：只有等值查询的场景
7.有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O（log（N））
8.有序数组查询效率高，更新效率低
9.有序数组的适用场景：静态存储引擎。
10.二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子
11.二叉搜索树：查询时间复杂度O（log（N）），更新时间复杂度O（Iog（N））
12.数据库存储大多不适用二叉树，因为树高过高，会适用N叉树
13.InnoDB中的索引模型：B+Tree
14.索引类型：主键索引、非主键索引
主键索引的叶子节点存的是整行的数据（聚簇索引），非主键索引的叶子节点内容是主键的值（二级索引）15.主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次（回表）
16.一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。
17.从性能和存储空间方面考量，自增主键往往是更合理的选择。
思考题：
如果删除，新建主键索引，会同时去修改普通索引对应的主键索引，性能消耗比较大。删除重建普通索引貌似影响不大，不过要注意在业务低谷期操作，避免影响业务。
~~~

## 05 | 深入浅出索引（下）

### 总结

~~~markdown
1.覆盖索引：
	如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少|O磁盘读写读取正行数据
2.最左前缀原则
	联合索引的最左N个字段，也可以是字符串索引的最左M个字符
3.联合索引
	根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1或age=1and name=‘张三’可以使用索引，单以name=‘张三’不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。
4.索引下推
	like 'hello%'and age > 10检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age < 10的数据，再进行回表查询，减少回表率，提升检索速度
~~~



## 06 | 全局锁与表锁：给表加个字段怎么有这么多阻碍

### 总结

~~~markdown
1.全局锁命令：flush tables with read lock
2.全局锁典型使用场景是，做全库逻辑备份
3.官方自带的逻辑备份工具mysqldump，当mysqldump使用参数-single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性试图。而由于MVCC的支持，这个过程中数据是可以正常更新的。
4.由于MyISAM不支持事务，只能使用ftwrl
5.set global readonly = true 设置为全库只读，如果发生异常重启之后，还是一直保持readonly状态
6.DML:增删改查数据、DDL:修改表结构
7.使用全局锁，DML和DDL都将被锁住
8.表级锁分为两种：一种是表锁，一种是元数据锁（meta data lock,MDL）,表锁的语法是lock tables...read/write。与ftwrl类似，可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables 语法除了会限制别的线程，也会限定了本线程接下来的操作对象。另一种表级锁是MDL，MySQL 5.5版本中引入了MDL，对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加DML写锁。读锁之间不互斥，读写之间、写锁之间是互斥的。
9.使用NOWAIT/WAIT n 这个语法安全的给小表加字段
~~~



## 07 | 行锁功过：怎么减少行锁对性能的影响

### 两阶段锁协议？

~~~markdown
在 InnoDB 事务中，行锁是在使用的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。所以，在开发中，如果在事务中需要锁多行，需要把最有可能造成锁冲突的放到最后执行。
~~~

### 死锁的概念是什么?举例说明出现死锁的情况.

~~~markdown
在并发系统中，不同线程出现循环资源依赖的情况，涉及的线程都在等待其他线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。

事务 A:begin; update t set k = k+1 where id = 1; ----------------> update t set k = k+1 where id = 2; --------------------->
事务 B:----------------------------------------> begin; update t set k = k+1 where id = 2; -------------->update t set k =k+1 where id = 1;
~~~

### 死锁的处理策略有哪两种?

~~~markdown
* 第一种策略是，直接进入等待，直到超时。超时时间可以通过参数innodb_lock_wait_timeout来设置。
		默认设置的时间为 50s
* 另一种策略是，发起死锁检测机制，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect设置为on
		默认开启
~~~

### 如何解决热点行更新导致的并发问题？

~~~markdown
* 如果能确保这个业务一定不会出现死锁，可以临时把死锁检测关闭掉。一般不建议采用
* 尽量从设计上优化并发问题，考虑通过将一行改成逻辑上的多行来减少锁冲突。
* 控制并发度
~~~



## 08 | 事务到底是隔离的还是不隔离的

### MySQL 中视图的概念

~~~markdown
在 MySQL 中有两个“视图”概念：
	* 一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view....,它的查询方法与表一样。
	* 另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。
~~~

### 事务是如何实现的MVCC呢

~~~markdown
1. InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id（严格递增）。
2. 每一行数据也都会有多个版本，每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本写到 undo log 里，并且在新的数据版本中，能够有信息可以直接拿到它。
~~~

### 什么是当前读

~~~markdown
更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”。除了update语句外，select语句如果加锁，也是当前读。
mysql> select k from t where id=1 lock in share mode;
mysql> select k from t where id=1 for update;
~~~

### RR 和 RC 的区别

~~~markdown
* 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；
* 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。
~~~

### 说明：

​	**“start transaction with consistent snapshot; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。**

 ## 09 | 普通索引和唯一索引，应该怎么选择

### 选择唯一索引还是普通索引

~~~markdown
对于查询过程来说：
	普通索引，查到满足条件的数据以后，还会继续查询。直到第一条不满足条件的数据为止。
	唯一索引，查到满足条件的数据以后，停止检索直接返回。
	但是，两者之间的性能差距微乎其微。因为 Innodb 是根据数据页来读的。
	
对于插入过程来说：
	如果数据页在内存中就直接更新，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。
	change buffer，实际上它是可以持久化的数据。
~~~

### change buffer的使用场景

~~~markdown
适用于写多读少的场景；
因为merge的时候是真正进行数据更新的时刻，而change buffer的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。
~~~

### change buffer 和 redo log

~~~markdown
1. 如果数据页在内存中，直接更新内存；
2. 没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个信息
3. 将上述两个动作记入redo log中。
redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。
~~~



## 10 | MySQL为什么有时候会选错索引？

~~~markdown
查看语句的执行情况，sql 语句前面加 explain
~~~

