## 01|基础架构:一条SQL查询语句是如何执行的

1. MySQL的框架有几个组件, 各是什么作用? 

   ~~~markdow
   客户端：提供对外服务，连接mysql服务端
   连接器：管理连接，权限校验
   缓存：存储、查询缓存
   分析器：词法分析、语法分析
   优化器：执行计划生成，选择索引
   执行器：操作引擎，返回结果
   存储引擎：存储数据，提供读写接口
   ~~~

2. Server层和存储引擎层各是什么作用?

   ~~~markdown
   server层：管理连接、校验sql、优化sql、通过server中的执行器调用存储引擎的接口，返回数据
   存储引擎：存储数据、提供读写接口
   ~~~

3. you have an error in your SQL syntax 这个保存是在词法分析里还是在语法分析里报错?

   ~~~markdown
   会在语法分析时报错
   ~~~

4. 对于表的操作权限验证在哪里进行?

   ~~~markdown
   执行器
   ~~~

5. 
   执行器的执行查询语句的流程是什么样的?

   ~~~markdown
   > select * from T where ID=10;
   1. 首先判断你对要执行的表有没有权限
   2. 如果没有就返回没有权限的错误
   3. 如果有权限就执行查询操作，如果ID没有索引，就调用innoDB引擎接口取第一行，如果ID =10，就讲结果存到结果集中，如果不是就跳过。
   4. 调用存储引擎接口取下一行，重复相同的判断逻辑，直到取到这个表的最后一行
   5. 执行器将满足条件的结果集返回给客户端
   ~~~

## 02|日志系统：一条SQL更新语句是如何执行的

1. redo log的概念是什么? 为什么会存在.

   ~~~markdown
   redo log是重做日志，主要用于mysql发生异常重启后的一种数据恢复手段。保证了数据一致性。归根到底是Mysql为了实现WAL机制的一种手段，因为Mysql进行更新操作，为了能够更快的，采用异步写回磁盘的技术。写入内存后就返回，但是会存在crash后内存数据丢失的隐患，而redo log具备crach safe能力。
   ~~~

2. 什么是WAL(write-ahead log)机制, 好处是什么.

   ~~~markdown
   WAL机制是写前日志，也就是Mysql更新操作后在真正的写入磁盘前先记录日志。好处是不用每一次操作都实时把数据写盘。就算crash后也可以通过redo log恢复，所以能够快速响应sql语句
   ~~~

3. redo log 为什么可以保证crash safe机制.

   ~~~markdown
   因为redo log 是每次更新操作完成后，就一定会写入的，如果写入失败，这说明本次操作失败，事务也不可能提交。redo log 内部是基于页的，记录了这个页的字段变化，只要crash后读取redo log进行重放就可以恢复数据。
   ~~~

4. binlog的概念是什么, 起到什么作用, 可以做crash safe吗? 

   ~~~markdown
   bin log 属于归档日志，属于Mysql Server层的日志。可以起到数据全量备份的作用。当需要恢复数据时，可以取出某个时间范围内的bin log进行重放恢复。但是bin log不可以做crash safe，因为crash之前，bin log可能没有写入完全Mysql就挂掉了。所以需要配合redo log才可以进行 crash safe
   ~~~

5. binlog和redolog的不同点有哪些? 

   ~~~markdown
   redo log 存在于innoDB引擎中、具备crash safe能力、循环写，满了就覆盖从头写，记录的是基于页的物理变化，是物理日志。
   binlog 属于server层，不具备 crash safe能力，可以追加写，不会覆盖。记录的是逻辑变化，是逻辑日志。
   ~~~

6. 物理一致性和逻辑一直性各应该怎么理解? 

   ~~~markdown
   前者是数据一致性，后者是行为一致性。
   ~~~

7. 执行器和innoDB在执行update语句时候的流程是什么样的?

   ~~~markdown
   1.判断数据也是否在内存中
   2.如果不存在，就从磁盘加载到内存中，如果存在就省略这一步
   3.将这一行更改的数据进行运算
   4.写入新行
   5.新行更新到内存
   6.写入redo log处于prepare阶段
   7.写入binlog
   8.提交事务，处于commit状态
   ~~~

8. 如果数据库误操作, 如何执行数据恢复?

   ~~~markdown
   数据库误删，就可以找到距离误操作最近的时间节点前的bin log，重放到临时数据库里，然后根据当天误删的数据恢复到线上数据库。
   ~~~

9. 什么是两阶段提交, 为什么需要两阶段提交, 两阶段提交怎么保证数据库中两份日志间的逻辑一致性(什么叫逻辑一致性)?

   ~~~markdown
   二阶段提交为；在一次update操作中，写入 redo log 进入 prepare阶段，然后写入 bin log，提交事务 redo log 处于commit阶段。保证了两分日志的逻辑一致性。
   ~~~

10. 如果不是两阶段提交, 先写redo log和先写bin log两种情况各会遇到什么问题?

    ~~~markdown
    先写 redo log，crash之后，bin log备份是少了一次更新操作，与当前数据不一致；
    先写 bin log，crash之后，由于redo log没有写入，事务无效，当mysql重启时，数据丢失；
    ~~~



## 03 | 事务隔离：为什么你改了我还看不见？

1. 事务的概念是什么?

   ~~~markdown
   事务就是保证一组数据库操作，要么全部成功，要么全部失败。
   ~~~

2. mysql的事务隔离级别读未提交, 读已提交, 可重复读, 串行各是什么意思?

   ~~~markdown
   读未提交：一个事务还没有提交，它做的变更就可以被别的事务看到。
   读已提交：一个事务提交之后，它做的变更就可以被其他事务看到。
   可重复读：一个事务执行的过程中看到的数据，总是根这个时候刚启动时看到的数据是一致的。
   串行化：对于同一行记录，”写“和”读“都会加”锁“，当出现读写冲突是，后访问的事务必须等待前一个事务执行完成，才能执行。
   ~~~

3. 读已提交, 可重复读是怎么通过视图构建实现的?

   ~~~markdown
   读已提交：会在事务中的每一个sql语句执行的时候都为对应的SQL创建一个一致性视图。此时这个SQL能读取到已提交的事务对数据的操作。
   可重复读：会在事务开启的时候，为整个事务创建一个一致性试图，这个试图会贯穿到这个事务执行结束。在整个事务执行过程中，都使用这个视图中的数据作为一致性读的依据。
   ~~~

4. 可重复读的使用场景举例? 对账的时候应该很有用?

   ~~~markdown
   对账的时候
   库管盘货
   ~~~

5. 事务隔离是怎么通过read-view(读视图)实现的?

   ~~~markdown
   每一行数据会有多个版本，当我们要去读取数据的时候，要判断这个数据的版本号，对当前事务而言，是否可见，如果不可见，则要根据undo log 计算得到上一个版本，如果上一个版本也不符合要求，则要找到再上一个版本，直到找到对应正确的数据版本。
   ~~~

6. 并发版本控制(MCVV)的概念是什么, 是怎么实现的?

   ~~~markdown
   同一个数据行，在数据库中存在多个版本号，这个版本号可以理解为当初操作这行数据的事务的事务ID。当多个事务在并发进行的时候，判断某个事务是否可以读取到某一行时，
   会使用行的版本号，和当前事务的ID进行比较。如果发现比这个事务ID小，表示之前的事务提交的操作，对当前事务来说，此版本的数据可见。
   如果发现这个数据的版本号比当前事务的ID大，则表示有未来发生的事务提交生成的，对当前事务来说，此版本的数据不可见。
   如果发现这个竖行的版本号刚好等于某个正在运行的是事务ID，表示当前数据是由正运行的某个事务提交生成的，对当前事务来说，此版本数据不可见。
   如果当前事务自己修改的数据，当前事务还是可以看到的。
   ~~~

7. 使用长事务的弊病? 为什么使用常事务可能拖垮整个库?

   ~~~markdown
   长事务导致表空间持续增长，即便是事务提交或者回滚后，回滚表空间被是否后，表空间大小仍然不会被缩小。
   长事务的存在导致锁发生冲突或等待的几率大大增加。
   如果某个应用有发生锁等待后尝试重新建立连接的机制，那么在发生锁等待或冲突的时候，应用就会不断地发起新的连接，导致MySQL的连接数被占用爆满。MySQL不能在提供连接服务，就挂掉了。
   ~~~

8. 事务的启动方式有哪几种? 

   ~~~markdown
   begin；-一致性读的视图不会马上创建，而是在执行begin后面的第一个操作innodb表的SQL语句时生成。这个SQL可以是select，update，delete，insert。事务ID也是此时被分配的
   start transaction；一和begin的功能效果一样。
   start transaciton with consistent snapshot；一该语句执行后，会马上创建一致性读的视图。 这个是它和begin的区别。事务ID也是此时被分配的。
   ~~~

9. commit work and chain的语法是做什么用的? 

   ~~~markdown
   提交上一个事务，并且再开启一个新的事务。它的功能等效于：commit+ begin。
   ~~~

10. 怎么查询各个表中的长事务?

    ~~~markdown
    select* from information_schema. innodb_trx;
    这个表中记录了所有正在运行的事务信息,里面有事务的开始时间。可以从这里看出哪些事务运行的时间比较长。
    ~~~

11. 如何避免长事务的出现?

    ~~~markdown
    从数据库方面：
    a.设置autocommit=1，不要设置为0。
    b.写脚本监控information_schemal.innodb_trx表中数据内容，发现长事务，kil掉它。
    c.配置SQL语句所能执行的最大运行时间，如果查过最大运行时间后，中断这个运行事情长的SQL语句。
    d.设置回滚表空单独存放，便于回收表空间。
    从业务代码方面：
    a.确认是否使用了autocommit=0的配置，如果有关闭它，然后再业务代码中手动的使用begin；commit来操作。
    b.检查业务逻辑代码，能拆分为小事务的不要用大事务。
    c.检查代码，把没有必要的select语句被事务包裹的情况去掉。
    ~~~



## 深入浅出索引（上）

1. 总结：

   ~~~markdown
   1.索引的作用：提高数据查询效率
   2.常见索引模型：哈希表、有序数组、搜索树
   3.哈希表：键-值（key- value）。
   4.哈希思路：把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置
   5.哈希冲突的处理办法：链表
   6.哈希表适用场景：只有等值查询的场景
   7.有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O（log（N））
   8.有序数组查询效率高，更新效率低
   9.有序数组的适用场景：静态存储引擎。
   10.二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子
   11.二叉搜索树：查询时间复杂度O（log（N）），更新时间复杂度O（Iog（N））
   12.数据库存储大多不适用二叉树，因为树高过高，会适用N叉树
   13.InnoDB中的索引模型：B+Tree
   14.索引类型：主键索引、非主键索引
   主键索引的叶子节点存的是整行的数据（聚簇索引），非主键索引的叶子节点内容是主键的值（二级索引）15.主键索引和普通索引的区别：主键索引只要搜索ID这个B+Tree即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次（回表）
   16.一个数据页满了，按照B+Tree算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。
   17.从性能和存储空间方面考量，自增主键往往是更合理的选择。
   思考题：
   如果删除，新建主键索引，会同时去修改普通索引对应的主键索引，性能消耗比较大。删除重建普通索引貌似影响不大，不过要注意在业务低谷期操作，避免影响业务。
   ~~~

   

